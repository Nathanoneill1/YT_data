<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Video Database Dashboard</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        {% raw %}
        const { useState, useEffect, useRef } = React;

        const Sidebar = ({ isCollapsed, activeItem, setActiveItem }) => {
            const menuItems = [
                { id: 'dashboard', label: 'Dashboard', icon: null },
                { id: 'baseline-tracker', label: 'Baseline Tracker', icon: null },
                { id: 'video-database', label: 'Video Database', icon: null }
            ];

            return (
                <div className={`sidebar ${isCollapsed ? 'collapsed' : ''}`}>
                    <div className="channel-info">
                        <div className="profile-picture">N</div>
                        <div className="channel-name">Nate O'Neill</div>
                        <div className="edit-icon">⚙️</div>
                    </div>
                    <nav className="nav-menu">
                        {menuItems.map(item => (
                            <div 
                                key={item.id}
                                className={`nav-item ${activeItem === item.id ? 'active' : ''}`}
                                onClick={() => setActiveItem(item.id)}
                            >
                                <span className="nav-label">{item.label}</span>
                            </div>
                        ))}
                    </nav>
                </div>
            );
        };

        const Header = ({ onToggleSidebar }) => {
            return (
                <header className="header">
                    <div className="header-left">
                        <div className="menu-icon" onClick={onToggleSidebar}>☰</div>
                        <div className="logo">
                            <span className="logo-icon">▶</span>
                            <span className="logo-text">Baseline Tracker</span>
                        </div>
                    </div>
                    <div className="search-bar">
                        <input type="text" placeholder="Search across your channel" />
                    </div>
                </header>
            );
        };

        const DailyDataModal = ({ isOpen, onClose, onSubmit }) => {
            const [ctrFile, setCtrFile] = useState(null);
            const [impressionFile, setImpressionFile] = useState(null);

            const handleCtrFileChange = (e) => {
                setCtrFile(e.target.files[0]);
            };

            const handleImpressionFileChange = (e) => {
                setImpressionFile(e.target.files[0]);
            };

            const handleSubmit = () => {
                if (ctrFile && impressionFile) {
                    onSubmit({ ctrFile, impressionFile });
                    setCtrFile(null);
                    setImpressionFile(null);
                    onClose();
                } else {
                    alert('Please select both CTR and Impression files');
                }
            };

            if (!isOpen) return null;

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal-content" onClick={(e) => e.stopPropagation()}>
                        <div className="modal-header">
                            <h2>Daily Data</h2>
                            <button className="close-btn" onClick={onClose}>×</button>
                        </div>
                        
                        <div className="modal-body">
                            <div className="file-sections">
                                <div className="file-section">
                                    <h3>CTR File</h3>
                                    <div className="file-upload-area">
                                        <input 
                                            type="file" 
                                            id="ctr-file" 
                                            onChange={handleCtrFileChange}
                                            accept=".csv,.xlsx,.xls"
                                            style={{ display: 'none' }}
                                        />
                                        <label htmlFor="ctr-file" className="file-upload-btn">
                                            <div className="upload-icon">
                                                <span className="plus-icon">+</span>
                                            </div>
                                            <span className="upload-text">Add New</span>
                                        </label>
                                        {ctrFile && (
                                            <div className="file-selected">
                                                <span className="file-name">{ctrFile.name}</span>
                                                <button 
                                                    className="remove-file-btn" 
                                                    onClick={() => setCtrFile(null)}
                                                >
                                                    ×
                                                </button>
                                            </div>
                                        )}
                                    </div>
                                </div>

                                <div className="file-section">
                                    <h3>Impression File</h3>
                                    <div className="file-upload-area">
                                        <input 
                                            type="file" 
                                            id="impression-file" 
                                            onChange={handleImpressionFileChange}
                                            accept=".csv,.xlsx,.xls"
                                            style={{ display: 'none' }}
                                        />
                                        <label htmlFor="impression-file" className="file-upload-btn">
                                            <div className="upload-icon">
                                                <span className="plus-icon">+</span>
                                            </div>
                                            <span className="upload-text">Add New</span>
                                        </label>
                                        {impressionFile && (
                                            <div className="file-selected">
                                                <span className="file-name">{impressionFile.name}</span>
                                                <button 
                                                    className="remove-file-btn" 
                                                    onClick={() => setImpressionFile(null)}
                                                >
                                                    ×
                                                </button>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="modal-footer">
                            <button className="cancel-btn" onClick={onClose}>Cancel</button>
                            <button className="submit-btn" onClick={handleSubmit}>Submit</button>
                        </div>
                    </div>
                </div>
            );
        };

        const ViewVideoModal = ({ isOpen, onClose, video }) => {
            if (!isOpen || !video) return null;

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal-content view-modal" onClick={(e) => e.stopPropagation()}>
                        <div className="modal-header">
                            <h2>{video.title} - Performance Data</h2>
                            <button className="close-btn" onClick={onClose}>×</button>
                        </div>
                        
                        <div className="modal-body">
                            <div className="performance-table-container">
                                <table className="performance-table">
                                    <thead>
                                        <tr>
                                            <th>Date</th>
                                            <th>Day</th>
                                            <th>Daily CTR</th>
                                            <th>Daily Impressions</th>
                                            <th>Total CTR</th>
                                            <th>Total Impressions</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {video.performanceData.map((row, index) => (
                                            <tr key={index}>
                                                <td>{row.date}</td>
                                                <td>{row.day}</td>
                                                <td>{row.dailyCTR}%</td>
                                                <td>{row.dailyImpressions.toLocaleString()}</td>
                                                <td>{row.totalCTR}%</td>
                                                <td>{row.totalImpressions.toLocaleString()}</td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        <div className="modal-footer">
                            <button className="cancel-btn" onClick={onClose}>Close</button>
                        </div>
                    </div>
                </div>
            );
        };

        const EditVideoModal = ({ isOpen, onClose, onSubmit, video }) => {
            const [ctrFile, setCtrFile] = useState(null);
            const [impressionFile, setImpressionFile] = useState(null);

            const handleCtrFileChange = (e) => {
                setCtrFile(e.target.files[0]);
            };

            const handleImpressionFileChange = (e) => {
                setImpressionFile(e.target.files[0]);
            };

            const handleSubmit = () => {
                const updates = {};
                if (ctrFile) updates.ctrFile = ctrFile;
                if (impressionFile) updates.impressionFile = impressionFile;
                
                if (Object.keys(updates).length > 0) {
                    onSubmit(updates);
                    setCtrFile(null);
                    setImpressionFile(null);
                    onClose();
                } else {
                    alert('Please select at least one file to update');
                }
            };

            if (!isOpen || !video) return null;

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal-content" onClick={(e) => e.stopPropagation()}>
                        <div className="modal-header">
                            <h2>Edit Video Files</h2>
                            <button className="close-btn" onClick={onClose}>×</button>
                        </div>
                        
                        <div className="modal-body">
                            <div className="current-files">
                                <h3>Current Files:</h3>
                                <div className="current-file-list">
                                    <div className="current-file-item">
                                        <span className="file-label">CTR File:</span>
                                        <span className="file-name">{video.ctrFile || 'No file uploaded'}</span>
                                    </div>
                                    <div className="current-file-item">
                                        <span className="file-label">Impression File:</span>
                                        <span className="file-name">{video.impressionFile || 'No file uploaded'}</span>
                                    </div>
                                </div>
                            </div>

                            <div className="file-sections">
                                <div className="file-section">
                                    <h3>Replace CTR File</h3>
                                    <div className="file-upload-area">
                                        <input 
                                            type="file" 
                                            id="edit-ctr-file" 
                                            onChange={handleCtrFileChange}
                                            accept=".csv,.xlsx,.xls"
                                            style={{ display: 'none' }}
                                        />
                                        <label htmlFor="edit-ctr-file" className="file-upload-btn">
                                            <div className="upload-icon">
                                                <span className="plus-icon">+</span>
                                            </div>
                                            <span className="upload-text">Replace File</span>
                                        </label>
                                        {ctrFile && (
                                            <div className="file-selected">
                                                <span className="file-name">{ctrFile.name}</span>
                                                <button 
                                                    className="remove-file-btn" 
                                                    onClick={() => setCtrFile(null)}
                                                >
                                                    ×
                                                </button>
                                            </div>
                                        )}
                                    </div>
                                </div>

                                <div className="file-section">
                                    <h3>Replace Impression File</h3>
                                    <div className="file-upload-area">
                                        <input 
                                            type="file" 
                                            id="edit-impression-file" 
                                            onChange={handleImpressionFileChange}
                                            accept=".csv,.xlsx,.xls"
                                            style={{ display: 'none' }}
                                        />
                                        <label htmlFor="edit-impression-file" className="file-upload-btn">
                                            <div className="upload-icon">
                                                <span className="plus-icon">+</span>
                                            </div>
                                            <span className="upload-text">Replace File</span>
                                        </label>
                                        {impressionFile && (
                                            <div className="file-selected">
                                                <span className="file-name">{impressionFile.name}</span>
                                                <button 
                                                    className="remove-file-btn" 
                                                    onClick={() => setImpressionFile(null)}
                                                >
                                                    ×
                                                </button>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="modal-footer">
                            <button className="cancel-btn" onClick={onClose}>Cancel</button>
                            <button className="submit-btn" onClick={handleSubmit}>Update Files</button>
                        </div>
                    </div>
                </div>
            );
        };

        // ---------- Updated BaselineTracker component starts here ----------
        const BaselineTracker = ({ videos }) => {
            const [impressionValue, setImpressionValue] = useState('');
            const [predictedCTR, setPredictedCTR] = useState(null);
            const [zoom, setZoom] = useState(1); // 1 = full-range view, >1 zoomed in
            const [dataPan, setDataPan] = useState({ x: 0, y: 0 }); // pan in data units (impressions, ctr)
            const [isDragging, setIsDragging] = useState(false);
            const dragRef = useRef({ startMouse: null, startPan: null });
            const svgRef = useRef(null);

            // Chart layout constants (pixel-space)
            const margin = { left: 80, right: 30, top: 40, bottom: 60 };
            const chartW = 370; // width in px for plotting area (kept to match original layout)
            const chartH = 320;
            const svgWidth = margin.left + chartW + margin.right;
            const svgHeight = margin.top + chartH + margin.bottom;

            // Aggregate all data points from all videos using cumulative values
            const getAllDataPoints = () => {
                const allPoints = [];
                videos.forEach(video => {
                    if (video.performanceData) {
                        video.performanceData.forEach(dataPoint => {
                            // Use the total (cumulative) values from each row
                            allPoints.push({
                                impressions: dataPoint.totalImpressions,
                                ctr: dataPoint.totalCTR,
                                videoTitle: video.title,
                                date: dataPoint.date,
                                day: dataPoint.day
                            });
                        });
                    }
                });
                // sort by impressions ascending for trend calculation
                allPoints.sort((a,b) => a.impressions - b.impressions);
                return allPoints;
            };

            const dataPoints = getAllDataPoints();

            // Base data domain (before zoom/pan)
            const dataXMax = dataPoints.length > 0 ? Math.max(...dataPoints.map(p => p.impressions)) : 20000;
            const dataYMax = dataPoints.length > 0 ? Math.max(...dataPoints.map(p => p.ctr)) : 8;
            const dataXMin = 0;
            const dataYMin = 0;

            // Visible data range based on zoom and pan
            const getVisibleRange = () => {
                // visible span in data units shrinks as zoom increases
                const fullXSpan = Math.max(1, dataXMax - dataXMin);
                const fullYSpan = Math.max(0.1, dataYMax - dataYMin);

                const visibleXSpan = fullXSpan / zoom;
                const visibleYSpan = fullYSpan / zoom;

                // center base: middle of the data domain
                const centerX = dataXMin + fullXSpan / 2 - dataPan.x;
                const centerY = dataYMin + fullYSpan / 2 - dataPan.y;

                let startX = centerX - visibleXSpan / 2;
                let endX = centerX + visibleXSpan / 2;
                let startY = centerY - visibleYSpan / 2;
                let endY = centerY + visibleYSpan / 2;

                // clamp to domain
                if (startX < dataXMin) {
                    startX = dataXMin;
                    endX = Math.min(dataXMin + visibleXSpan, dataXMin + fullXSpan);
                }
                if (endX > dataXMin + fullXSpan) {
                    endX = dataXMin + fullXSpan;
                    startX = Math.max(dataXMin, endX - visibleXSpan);
                }

                if (startY < dataYMin) {
                    startY = dataYMin;
                    endY = Math.min(dataYMin + visibleYSpan, dataYMin + fullYSpan);
                }
                if (endY > dataYMin + fullYSpan) {
                    endY = dataYMin + fullYSpan;
                    startY = Math.max(dataYMin, endY - visibleYSpan);
                }

                return { startX, endX, startY, endY };
            };

            const visibleRange = getVisibleRange();

            // helpers: map data -> screen
            const xToScreen = (x) => {
                const t = (x - visibleRange.startX) / (visibleRange.endX - visibleRange.startX || 1);
                return margin.left + t * chartW;
            };
            const yToScreen = (y) => {
                const t = (y - visibleRange.startY) / (visibleRange.endY - visibleRange.startY || 1);
                // invert y for screen coords (0 at top)
                return margin.top + (1 - t) * chartH;
            };

            // Tick generation: more ticks when zoomed in
            const generateTickLabels = () => {
                const zoomFactor = Math.max(1, zoom);
                const maxTicks = 8;
                const minTicks = 3;
                const numTicks = Math.max(minTicks, Math.min(maxTicks, Math.round(3 + zoomFactor * 2)));

                // X ticks (impressions)
                const xTicks = [];
                const spanX = visibleRange.endX - visibleRange.startX;
                const niceStepX = niceNumber(spanX / (numTicks - 1));
                const firstTickX = Math.ceil(visibleRange.startX / niceStepX) * niceStepX;
                for (let val = firstTickX; val <= visibleRange.endX + 1e-6; val += niceStepX) {
                    xTicks.push({ value: val, x: xToScreen(val) });
                }

                // Y ticks (CTR)
                const yTicks = [];
                const spanY = visibleRange.endY - visibleRange.startY;
                const niceStepY = niceNumber(spanY / (numTicks - 1));
                const firstTickY = Math.ceil(visibleRange.startY / niceStepY) * niceStepY;
                for (let val = firstTickY; val <= visibleRange.endY + 1e-6; val += niceStepY) {
                    yTicks.push({ value: val, y: yToScreen(val) });
                }

                return { xTicks, yTicks };
            };

            // nice step helper (rounds to human-friendly increments)
            const niceNumber = (raw) => {
                if (!isFinite(raw) || raw <= 0) return 1;
                const exponent = Math.floor(Math.log10(raw));
                const fraction = raw / Math.pow(10, exponent);
                let niceFraction;
                if (fraction <= 1) niceFraction = 1;
                else if (fraction <= 2) niceFraction = 2;
                else if (fraction <= 5) niceFraction = 5;
                else niceFraction = 10;
                return niceFraction * Math.pow(10, exponent);
            };

            const tickLabels = generateTickLabels();

            // Drag handlers (pan in data units)
            const handleMouseDown = (e) => {
                if (!svgRef.current) return;
                setIsDragging(true);
                dragRef.current.startMouse = { x: e.clientX, y: e.clientY };
                dragRef.current.startPan = { ...dataPan };
            };

            const handleMouseMove = (e) => {
                if (!isDragging || !svgRef.current) return;
                const dx = e.clientX - dragRef.current.startMouse.x; // px
                const dy = e.clientY - dragRef.current.startMouse.y; // px

                // convert pixel delta to data delta using current visible spans
                const visibleXSpan = visibleRange.endX - visibleRange.startX;
                const visibleYSpan = visibleRange.endY - visibleRange.startY;

                const deltaDataX = (dx / chartW) * visibleXSpan;
                const deltaDataY = ( -dy / chartH) * visibleYSpan; // note sign: dragging down should decrease Y data center

                setDataPan({
                    x: dragRef.current.startPan.x - deltaDataX,
                    y: dragRef.current.startPan.y - deltaDataY
                });
            };

            const handleMouseUp = () => {
                setIsDragging(false);
            };

            // Wheel zoom centered on mouse
            const handleWheel = (e) => {
                e.preventDefault();
                const svg = svgRef.current;
                if (!svg) return;

                const rect = svg.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // convert mouse pixel to data coordinate
                const mouseDataX = visibleRange.startX + ((mouseX - margin.left) / chartW) * (visibleRange.endX - visibleRange.startX);
                const mouseDataY = visibleRange.startY + (1 - (mouseY - margin.top) / chartH) * (visibleRange.endY - visibleRange.startY);

                const deltaZoom = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(1, Math.min(30, zoom * deltaZoom)); // limit zoom between 1 and 30
                // compute new pan so mouseData stays at same screen position
                const fullXSpan = Math.max(1, dataXMax - dataXMin);
                const fullYSpan = Math.max(0.1, dataYMax - dataYMin);
                const newVisibleX = fullXSpan / newZoom;
                const newVisibleY = fullYSpan / newZoom;

                // new center should be such that mouseData is at same relative position
                const relX = (mouseDataX - visibleRange.startX) / (visibleRange.endX - visibleRange.startX || 1);
                const relY = (mouseDataY - visibleRange.startY) / (visibleRange.endY - visibleRange.startY || 1);

                const newStartX = mouseDataX - relX * newVisibleX;
                const newStartY = mouseDataY - relY * newVisibleY;
                const centerX = newStartX + newVisibleX / 2;
                const centerY = newStartY + newVisibleY / 2;

                // dataPan was used such that center = mid - pan, so: pan = mid - center
                const panX = (dataXMin + fullXSpan/2) - centerX;
                const panY = (dataYMin + fullYSpan/2) - centerY;

                setZoom(newZoom);
                setDataPan({ x: panX, y: panY });
            };

            const resetView = () => {
                setZoom(1);
                setDataPan({ x: 0, y: 0 });
            };

            // Trend line (linear regression) computed from data points
            const calculateTrendLine = () => {
                if (dataPoints.length < 2) return [];
                const n = dataPoints.length;
                const xs = dataPoints.map(p => p.impressions);
                const ys = dataPoints.map(p => p.ctr);
                const sumX = xs.reduce((a,b)=>a+b,0);
                const sumY = ys.reduce((a,b)=>a+b,0);
                const sumXY = xs.reduce((a,b,i)=>a + b * ys[i], 0);
                const sumXX = xs.reduce((a,b)=>a + b*b, 0);
                const denom = n * sumXX - sumX * sumX;
                const slope = denom === 0 ? 0 : (n * sumXY - sumX * sumY) / denom;
                const intercept = (sumY - slope * sumX) / n;

                const minX = Math.min(...xs);
                const maxX = Math.max(...xs);
                const points = [];
                const segments = 60;
                for (let i = 0; i <= segments; i++) {
                    const x = minX + (i / segments) * (maxX - minX);
                    const y = intercept + slope * x;
                    points.push({ x, y });
                }
                return points;
            };

            const trendLine = calculateTrendLine();

            const handlePredictCTR = () => {
                if (!impressionValue || trendLine.length < 2) return;
                
                const impressions = parseInt(impressionValue);
                if (isNaN(impressions)) return;

                // simple interpolation using trend line endpoints
                const first = trendLine[0];
                const last = trendLine[trendLine.length - 1];
                const slope = (last.y - first.y) / (last.x - first.x || 1);
                const intercept = first.y - slope * first.x;
                const predicted = slope * impressions + intercept;
                
                setPredictedCTR(Math.max(0, predicted).toFixed(2));
            };

            // dynamic tick visuals (font size & tick length scale with zoom)
            const tickFontSize = Math.min(14, 10 + Math.log10(zoom + 1) * 4);
            const tickLength = Math.min(14, 6 + Math.log10(zoom + 1) * 6);

            return (
                <div className="baseline-tracker-page">
                    <h1>Baseline Tracker</h1>
                    
                    {/* Chart Container */}
                    <div className="chart-container">
                        <div className="chart-header">
                            <h3>Cumulative CTR vs Total Impressions Trend</h3>
                            <div className="chart-controls">
                                <button onClick={resetView} className="reset-btn">Reset View</button>
                                <span className="zoom-info">Zoom: {Math.round(zoom * 100)}%</span>
                            </div>
                        </div>
                        <div 
                            className="chart-wrapper"
                            onWheel={handleWheel}
                        >
                            <svg 
                                ref={svgRef}
                                className="chart" 
                                viewBox={`0 0 ${svgWidth} ${svgHeight}`}
                                width={svgWidth}
                                height={svgHeight}
                                onMouseDown={handleMouseDown}
                                onMouseMove={handleMouseMove}
                                onMouseUp={handleMouseUp}
                                onMouseLeave={handleMouseUp}
                            >
                                {/* Y-axis */}
                                <line x1={margin.left} y1={margin.top} x2={margin.left} y2={margin.top + chartH} stroke="#3f3f3f" strokeWidth="2"/>
                                <text x={margin.left - 50} y={margin.top + 10} className="axis-label">CTR</text>
                                <text x={margin.left - 55} y={margin.top + 18} className="axis-arrow">↑</text>
                                
                                {/* Y-axis ticks and labels - dynamic based on visible range */}
                                {tickLabels.yTicks.map((tick, index) => (
                                    <g key={index} >
                                        <text x={margin.left - 30} y={tick.y + 4} className="tick-label" style={{ fontSize: `${tickFontSize}px` }}>{tick.value.toFixed(1)}%</text>
                                        <line x1={margin.left - tickLength} y1={tick.y} x2={margin.left + 4} y2={tick.y} stroke="#3f3f3f"/>
                                    </g>
                                ))}
                                
                                {/* X-axis */}
                                <line x1={margin.left} y1={margin.top + chartH} x2={margin.left + chartW} y2={margin.top + chartH} stroke="#3f3f3f" strokeWidth="2"/>
                                <text x={margin.left + chartW/2} y={margin.top + chartH + 50} className="axis-label">Total Impressions</text>
                                <text x={margin.left + chartW - 10} y={margin.top + chartH + 25} className="axis-arrow">→</text>
                                
                                {/* X-axis ticks and labels - dynamic based on visible range */}
                                {tickLabels.xTicks.map((tick, index) => (
                                    <g key={index}>
                                        <text x={tick.x} y={margin.top + chartH + 22} className="tick-label" style={{ fontSize: `${tickFontSize}px` }}>{Math.round(tick.value).toLocaleString()}</text>
                                        <line x1={tick.x} y1={margin.top + chartH - tickLength/2} x2={tick.x} y2={margin.top + chartH + tickLength/2} stroke="#3f3f3f"/>
                                    </g>
                                ))}

                                {/* Transparent rect to capture drag/wheel events inside plotting area */}
                                <rect
                                    x={margin.left}
                                    y={margin.top}
                                    width={chartW}
                                    height={chartH}
                                    fill="transparent"
                                />

                                {/* Data points */}
                                <g className="data-layer">
                                    {dataPoints.map((point, index) => {
                                        // only draw points that fall within visible range (small performance optimization)
                                        if (point.impressions < visibleRange.startX - 1 || point.impressions > visibleRange.endX + 1) return null;
                                        if (point.ctr < visibleRange.startY - 1 || point.ctr > visibleRange.endY + 1) return null;
                                        const cx = xToScreen(point.impressions);
                                        const cy = yToScreen(point.ctr);
                                        const r = Math.max(2.5, Math.min(6, 3 * Math.log10(zoom + 1)));
                                        return (
                                            <circle
                                                key={index}
                                                cx={cx}
                                                cy={cy}
                                                r={r}
                                                fill="#1c62b9"
                                                opacity="0.9"
                                            />
                                        );
                                    })}

                                    {/* Trend line (smooth curve) */}
                                    {trendLine.length > 2 && (
                                        <path
                                            d={trendLine.map((pt, i) => {
                                                const sx = xToScreen(pt.x);
                                                const sy = yToScreen(pt.y);
                                                return `${i === 0 ? 'M' : 'L'} ${sx} ${sy}`;
                                            }).join(' ')}
                                            stroke="#ff6b6b"
                                            strokeWidth="2"
                                            fill="none"
                                            strokeLinecap="round"
                                            strokeLinejoin="round"
                                        />
                                    )}

                                    {/* Prediction point */}
                                    {predictedCTR && impressionValue && (
                                        <circle
                                            cx={xToScreen(parseInt(impressionValue))}
                                            cy={yToScreen(parseFloat(predictedCTR))}
                                            r="6"
                                            fill="#ff6b6b"
                                            stroke="#ffffff"
                                            strokeWidth="2"
                                        />
                                    )}
                                </g>
                            </svg>
                        </div>
                    </div>
                    
                    {/* Controls */}
                    <div className="controls-section">
                        <div className="compare-section">
                            <span className="compare-label">Compare</span>
                            <div className="input-group">
                                <input
                                    type="number"
                                    placeholder="Imp. Value"
                                    value={impressionValue}
                                    onChange={(e) => setImpressionValue(e.target.value)}
                                    className="impression-input"
                                />
                                <button 
                                    className="go-button"
                                    onClick={handlePredictCTR}
                                >
                                    GO
                                </button>
                            </div>
                        </div>
                        
                        {predictedCTR && (
                            <div className="prediction-result">
                                <p>Predicted CTR: <strong>{predictedCTR}%</strong></p>
                            </div>
                        )}
                    </div>
                </div>
            );
        };
        // ---------- Updated BaselineTracker component ends here ----------

        const VideoDatabase = ({ videos, setVideos }) => {
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [isEditModalOpen, setIsEditModalOpen] = useState(false);
            const [isViewModalOpen, setIsViewModalOpen] = useState(false);
            const [editingVideo, setEditingVideo] = useState(null);
            const [viewingVideo, setViewingVideo] = useState(null);

            const handleAddVideo = () => {
                setIsModalOpen(true);
            };

            const parseCSV = (csvText) => {
                const lines = csvText.trim().split('\n');
                const headers = lines[0].split(',').map(h => h.trim());
                const data = [];
                
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',').map(v => v.trim());
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index];
                    });
                    data.push(row);
                }
                return data;
            };

            const processFileData = async (ctrFile, impressionFile) => {
                try {
                    // Parse CTR file with the specific format: "Date,Impressions click-through rate (%)"
                    const ctrText = await ctrFile.text();
                    const ctrData = parseCSV(ctrText);
                    
                    // Parse Impression file (assuming format: "Date,Impressions" or similar)
                    const impressionText = await impressionFile.text();
                    const impressionData = parseCSV(impressionText);
                    
                    console.log('CTR Data:', ctrData);
                    console.log('Impression Data:', impressionData);
                    
                    // Combine the data by date - assume both files have the same dates in the same order
                    const combinedData = [];
                    const maxLength = Math.max(ctrData.length, impressionData.length);
                    
                    for (let i = 0; i < maxLength; i++) {
                        const ctrRow = ctrData[i] || {};
                        const impressionRow = impressionData[i] || {};
                        
                        // Extract date and CTR from CTR file
                        const date = ctrRow['Date'] || impressionRow['Date'] || `Day ${i + 1}`;
                        const dailyCTR = parseFloat(ctrRow['Impressions click-through rate (%)'] || 0);
                        
                        // Extract impressions from impression file with format: "Date,Impressions"
                        const dailyImpressions = parseInt(impressionRow['Impressions'] || 0);
                        
                        // Only add rows that have valid data
                        if (dailyCTR > 0 && dailyImpressions > 0) {
                            combinedData.push({
                                date: date,
                                day: i + 1,
                                dailyCTR: dailyCTR,
                                dailyImpressions: dailyImpressions
                            });
                        }
                    }

                    if (combinedData.length === 0) {
                        throw new Error('No valid data found in uploaded files');
                    }

                    // Calculate total impressions and cumulative CTR using the correct formula:
                    // CTR_tot = (1 / Imp_tot) * Σ (CTR_n * Imp_n)
                    let totalImpressions = 0;
                    let sumCTRTimesImpressions = 0;
                    
                    const processedData = combinedData.map((row, index) => {
                        totalImpressions += row.dailyImpressions;
                        sumCTRTimesImpressions += (row.dailyCTR / 100) * row.dailyImpressions;
                        
                        // Apply the formula: CTR_tot = (1 / Imp_tot) * Σ (CTR_n * Imp_n)
                        const totalCTR = totalImpressions > 0 ? (1 / totalImpressions) * sumCTRTimesImpressions * 100 : 0;
                        
                        return {
                            ...row,
                            totalCTR: parseFloat(totalCTR.toFixed(2)),
                            totalImpressions: totalImpressions
                        };
                    });

                    console.log('Processed Data:', processedData);
                    return processedData;
                } catch (error) {
                    console.error('Error processing files:', error);
                    alert(`Error processing files: ${error.message}. Please check your file format.`);
                    return null;
                }
            };

            const handleModalSubmit = async (data) => {
                try {
                    const performanceData = await processFileData(data.ctrFile, data.impressionFile);
                    
                    if (performanceData === null) {
                        // File processing failed, don't create the video
                        return;
                    }
                    
                    const newVideo = {
                        id: videos.length + 1,
                        title: `Video ${videos.length + 1}`,
                        ctrFile: data.ctrFile.name,
                        impressionFile: data.impressionFile.name,
                        performanceData: performanceData
                    };
                    setVideos([...videos, newVideo]);
                } catch (error) {
                    console.error('Error processing video data:', error);
                    alert('Error processing files. Please try again.');
                }
            };

            const handleEditVideo = (id) => {
                const video = videos.find(v => v.id === id);
                setEditingVideo(video);
                setIsEditModalOpen(true);
            };

            const handleEditModalSubmit = (updates) => {
                setVideos(videos.map(v => {
                    if (v.id === editingVideo.id) {
                        const updatedVideo = { ...v };
                        if (updates.ctrFile) {
                            updatedVideo.ctrFile = updates.ctrFile.name;
                            // Reprocess data when files are updated
                            updatedVideo.performanceData = processFileData(updates.ctrFile, updates.impressionFile || v.impressionFile);
                        }
                        if (updates.impressionFile) {
                            updatedVideo.impressionFile = updates.impressionFile.name;
                            // Reprocess data when files are updated
                            updatedVideo.performanceData = processFileData(updates.ctrFile || v.ctrFile, updates.impressionFile);
                        }
                        return updatedVideo;
                    }
                    return v;
                }));
            };

            const handleViewVideo = (id) => {
                const video = videos.find(v => v.id === id);
                setViewingVideo(video);
                setIsViewModalOpen(true);
            };

            const handleDeleteVideo = (id) => {
                if (window.confirm('Are you sure you want to delete this video?')) {
                    setVideos(videos.filter(v => v.id !== id));
                }
            };

            return (
                <div className="video-database-page">
                    {/* Add New Video Section */}
                    <div className="add-new-video-section">
                        <button className="add-new-video-btn" onClick={handleAddVideo}>
                            <div className="add-new-video-icon">
                                <span className="plus-icon">+</span>
                            </div>
                            <span className="add-new-video-text">Add New Video</span>
                        </button>
                    </div>

                    {/* Video List */}
                    <div className="video-list">
                        {videos.map((video, index) => (
                            <div key={video.id} className="video-entry">
                                <span className="video-title">{video.title}</span>
                                <div className="video-actions">
                                    <button 
                                        className="action-btn view-btn" 
                                        onClick={() => handleViewVideo(video.id)}
                                        title="View performance data"
                                    >
                                        📈
                                    </button>
                                    <button 
                                        className="action-btn edit-btn" 
                                        onClick={() => handleEditVideo(video.id)}
                                        title="Edit video"
                                    >
                                        ⚙️
                                    </button>
                                    <button 
                                        className="action-btn delete-btn" 
                                        onClick={() => handleDeleteVideo(video.id)}
                                        title="Delete video"
                                    >
                                        ✕
                                    </button>
                                </div>
                            </div>
                        ))}
                    </div>

                    {/* Daily Data Modal */}
                    <DailyDataModal 
                        isOpen={isModalOpen}
                        onClose={() => setIsModalOpen(false)}
                        onSubmit={handleModalSubmit}
                    />

                    {/* Edit Video Modal */}
                    <EditVideoModal 
                        isOpen={isEditModalOpen}
                        onClose={() => {
                            setIsEditModalOpen(false);
                            setEditingVideo(null);
                        }}
                        onSubmit={handleEditModalSubmit}
                        video={editingVideo}
                    />

                    {/* View Video Modal */}
                    <ViewVideoModal 
                        isOpen={isViewModalOpen}
                        onClose={() => {
                            setIsViewModalOpen(false);
                            setViewingVideo(null);
                        }}
                        video={viewingVideo}
                    />
                </div>
            );
        };

        const Dashboard = () => {
            return (
                <div className="dashboard">
                    {/* Large Add Video Button */}
                    <div className="add-video-section">
                        <button className="add-video-btn">
                            <div className="add-video-icon">
                                <div className="plus-box">
                                    <span className="plus-icon">+</span>
                                </div>
                            </div>
                            <div className="add-video-text">
                                <h3>Add Video</h3>
                                <p>Upload a new video to your channel</p>
                            </div>
                        </button>
                    </div>
                </div>
            );
        };

        const MainContent = ({ activeView, videos, setVideos }) => {
            return (
                <main className="main-content">
                    {activeView === 'dashboard' && <Dashboard />}
                    {activeView === 'baseline-tracker' && <BaselineTracker videos={videos} />}
                    {activeView === 'video-database' && <VideoDatabase videos={videos} setVideos={setVideos} />}
                </main>
            );
        };

        const App = () => {
            const [activeView, setActiveView] = useState('dashboard');
            const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
            
            // Load videos from localStorage on component mount
            const [videos, setVideos] = useState(() => {
                const savedVideos = localStorage.getItem('yt-videos');
                if (savedVideos) {
                    try {
                        return JSON.parse(savedVideos);
                    } catch (error) {
                        console.error('Error parsing saved videos:', error);
                        return [];
                    }
                }
                // Default sample data if no saved data
                return [
                    { 
                        id: 1, 
                        title: 'Video 1', 
                        ctrFile: 'ctr_data_1.csv', 
                        impressionFile: 'impression_data_1.csv',
                        performanceData: [
                            { date: '2024-01-01', day: 1, dailyCTR: 6.0, dailyImpressions: 10000, totalCTR: 6.0, totalImpressions: 10000 },
                            { date: '2024-01-02', day: 2, dailyCTR: 7.0, dailyImpressions: 20000, totalCTR: 6.7, totalImpressions: 30000 },
                            { date: '2024-01-03', day: 3, dailyCTR: 6.0, dailyImpressions: 15000, totalCTR: 6.4, totalImpressions: 45000 }
                        ]
                    },
                    { 
                        id: 2, 
                        title: 'Video 2', 
                        ctrFile: 'ctr_data_2.csv', 
                        impressionFile: 'impression_data_2.csv',
                        performanceData: [
                            { date: '2024-01-01', day: 1, dailyCTR: 5.5, dailyImpressions: 12000, totalCTR: 5.5, totalImpressions: 12000 },
                            { date: '2024-01-02', day: 2, dailyCTR: 6.2, dailyImpressions: 18000, totalCTR: 5.9, totalImpressions: 30000 },
                            { date: '2024-01-03', day: 3, dailyCTR: 5.8, dailyImpressions: 14000, totalCTR: 5.8, totalImpressions: 44000 }
                        ]
                    }
                ];
            });

            // Save videos to localStorage whenever videos state changes
            useEffect(() => {
                localStorage.setItem('yt-videos', JSON.stringify(videos));
            }, [videos]);

            const toggleSidebar = () => {
                setSidebarCollapsed(!sidebarCollapsed);
            };

            return (
                <div className="app">
                    <Header onToggleSidebar={toggleSidebar} />
                    <div className="app-body">
                        <Sidebar 
                            isCollapsed={sidebarCollapsed} 
                            activeItem={activeView}
                            setActiveItem={setActiveView}
                        />
                        <MainContent activeView={activeView} videos={videos} setVideos={setVideos} />
                    </div>
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
        {% endraw %}
    </script>
</body>
</html>
